<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>ndarray</title>

    
    <link rel="stylesheet" href="rustdoc.css">
<link rel="stylesheet" href="rust.css">
<link rel="stylesheet" href="sliderust.css">
<script src="sliderust.js"></script>


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <h1 class="title">ndarray</h1>
    <p><br><br>
presented by Ulrik Sverdrup (bluss)</p>

<p>22 March 2016</p>

<p><small><a href="https://github.com/bluss/rust-ndarray">https://github.com/bluss/rust-ndarray</a></small></p>

<h1 id='what-is-ndarray' class='section-header'><a href='#what-is-ndarray'>What is ndarray?</a></h1>
<ul>
<li>A Rust library, compatible with stable Rust releases</li>
<li>Current version as of this talk is <a href="https://crates.io/crates/ndarray/"><code>ndarray 0.4.4</code></a></li>
</ul>

<h1 id='what-is-ndarray-1' class='section-header'><a href='#what-is-ndarray-1'>What is ndarray?</a></h1>
<p><em>A multidimensional container for general elements and for numerics</em></p>

<p>It’s an array with multiple dimensions.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>ndarray</span>::<span class='ident'>OwnedArray</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>array</span> <span class='op'>=</span> <span class='ident'>OwnedArray</span>::<span class='ident'>zeros</span>((<span class='number'>3</span>, <span class='number'>5</span>, <span class='number'>5</span>));
<span class='ident'>array</span>[[<span class='number'>1</span>, <span class='number'>1</span>, <span class='number'>1</span>]] <span class='op'>=</span> <span class='number'>9.</span>;</pre>

<ul>
<li>An in-memory data structure</li>
<li>Elements of arbitrary type</li>
</ul>

<h1 id='what-is-ndarray-2' class='section-header'><a href='#what-is-ndarray-2'>What is ndarray?</a></h1>
<p>It is bounds checked like a regular Rust data structure:</p>

<pre class='rust rust-example-rendered'>
<span class='ident'>array</span>[[<span class='number'>3</span>, <span class='number'>1</span>, <span class='number'>1</span>]] <span class='op'>=</span> <span class='number'>10.</span>;
<span class='comment'>// PANIC! thread &#39;&lt;main&gt;&#39; panicked at &#39;ndarray: index [3, 1, 1] is out of bounds for array of shape [3, 5, 5]&#39;</span></pre>

<p>and it supports numerics:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>OwnedArray</span>::<span class='ident'>from_vec</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>0.</span>, <span class='number'>1.</span>, <span class='number'>2.</span>, <span class='number'>1.</span>]);
<span class='kw'>let</span> <span class='ident'>x_hat</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>x</span> <span class='op'>/</span> <span class='ident'>x</span>.<span class='ident'>scalar_sum</span>();
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:5.2}&quot;</span>, <span class='ident'>x_hat</span>);
<span class='comment'>// OUTPUT: [ 0.00,  0.25,  0.50,  0.25]</span></pre>

<h1 id='array-types' class='section-header'><a href='#array-types'>Array Types</a></h1>
<ul>
<li>A unique-owner array called <code>OwnedArray&lt;A, D&gt;</code>

<ul>
<li>Where <code>A</code> is the element type, and <code>D</code> is the dimensionality</li>
</ul></li>
<li>Array views:

<ul>
<li><code>ArrayView&lt;A, D&gt;</code></li>
<li><code>ArrayViewMut&lt;A, D&gt;</code></li>
</ul></li>
<li>Like <code>Vec&lt;A&gt;</code> and its view types <code>&amp;[A]</code> and <code>&amp;mut [A]</code>.</li>
<li>Views allow composable algorithms; access to arrays or parts of them
is the same.</li>
<li>Views allow efficient and rustic expression of
divide and conquer algorithms.</li>
</ul>

<h1 id='representation' class='section-header'><a href='#representation'>Representation</a></h1>
<div style="text-align: center; margin-top: 10px">
<img src="rep-matrix.svg" height="600">
</div>

<h1 id='representation-1' class='section-header'><a href='#representation-1'>Representation</a></h1>
<div style="text-align: center; margin-top: 10px">
<img src="rep-view.svg" height="600">
</div>

<h1 id='representation-2' class='section-header'><a href='#representation-2'>Representation</a></h1>
<div style="text-align: center; margin-top: 10px">
<img src="rep-stride.svg" height="600">
</div>

<h1 id='representation-3' class='section-header'><a href='#representation-3'>Representation</a></h1>
<div style="text-align: center; margin-top: 10px">
<img src="rep-ndarray.svg" height="600">
</div>

<h1 id='slicing' class='section-header'><a href='#slicing'>Slicing</a></h1>
<div style="text-align: center; margin-top: 10px">
<img src="rep-slice.svg" height="600">
</div>

<h1 id='splitting' class='section-header'><a href='#splitting'>Splitting</a></h1>
<div style="text-align: center; margin-top: 10px">
<img src="split_at.svg" height="600">
</div>

<h1 id='views-and-iterators' class='section-header'><a href='#views-and-iterators'>Views and Iterators</a></h1>
<pre class='rust rust-example-rendered'>
.<span class='ident'>inner_iter</span>()     <span class='comment'>// each iterator has a corresponding</span>
.<span class='ident'>outer_iter</span>()     <span class='comment'>// mutable version too.</span>
.<span class='ident'>axis_iter</span>(<span class='ident'>Axis</span>)
.<span class='ident'>axis_chunks_iter</span>(<span class='ident'>Axis</span>, <span class='ident'>usize</span>)</pre>

<div style="text-align: center; margin: 0px">
<img src="axis_iter.svg" height="350">
</div>

<p>Iterators are a powerful way to access views of an array.</p>

<h1 id='an-array-view-of-anything' class='section-header'><a href='#an-array-view-of-anything'>An Array View of Anything</a></h1>
<ul>
<li>You don’t need an <code>OwnedArray</code>, you can create an array view of any data you
can get a slice of.</li>
</ul>

<pre class='rust rust-example-rendered'>
<span class='comment'>// Create a stack allocated Hilbert Matrix </span>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>data</span> <span class='op'>=</span> [<span class='number'>0.</span>; <span class='number'>1024</span>];
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>view</span> <span class='op'>=</span> <span class='ident'>ArrayViewMut</span>::<span class='ident'>from</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>data</span>[..])
                            .<span class='ident'>into_shape</span>((<span class='number'>32</span>, <span class='number'>32</span>)).<span class='ident'>unwrap</span>();
<span class='kw'>for</span> ((<span class='ident'>i</span>, <span class='ident'>j</span>), <span class='ident'>elt</span>) <span class='kw'>in</span> <span class='ident'>view</span>.<span class='ident'>indexed_iter_mut</span>() {
    <span class='op'>*</span><span class='ident'>elt</span> <span class='op'>=</span> <span class='number'>1.</span> <span class='op'>/</span> (<span class='number'>1.</span> <span class='op'>+</span> <span class='ident'>i</span> <span class='kw'>as</span> <span class='ident'>f32</span> <span class='op'>+</span> <span class='ident'>j</span> <span class='kw'>as</span> <span class='ident'>f32</span>);
}</pre>

<h1 id='higher-order-functions' class='section-header'><a href='#higher-order-functions'>Higher Order Functions</a></h1>
<pre class='rust rust-example-rendered'>
<span class='comment'>// Closure types in pseudocode!</span>
.<span class='ident'>map</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='op'>|</span><span class='kw-2'>&amp;</span><span class='ident'>A</span><span class='op'>|</span> <span class='op'>-&gt;</span> <span class='ident'>B</span>) <span class='op'>-&gt;</span> <span class='ident'>OwnedArray</span><span class='op'>&lt;</span><span class='ident'>B</span>, <span class='ident'>D</span><span class='op'>&gt;</span>
.<span class='ident'>mapv</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='op'>|</span><span class='ident'>A</span><span class='op'>|</span> <span class='op'>-&gt;</span> <span class='ident'>B</span>) <span class='op'>-&gt;</span> <span class='ident'>OwnedArray</span><span class='op'>&lt;</span><span class='ident'>B</span>, <span class='ident'>D</span><span class='op'>&gt;</span>
.<span class='ident'>map_inplace</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='op'>|</span><span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>A</span><span class='op'>|</span>)
.<span class='ident'>mapv_inplace</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='op'>|</span><span class='ident'>A</span><span class='op'>|</span> <span class='op'>-&gt;</span> <span class='ident'>A</span>)

.<span class='ident'>zip_mut_with</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>, <span class='ident'>rhs</span>: <span class='kw-2'>&amp;</span><span class='ident'>Array</span><span class='op'>&lt;</span><span class='ident'>B</span><span class='op'>&gt;</span>, <span class='op'>|</span><span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>A</span>, <span class='kw-2'>&amp;</span><span class='ident'>B</span><span class='op'>|</span>)</pre>

<p>Higher order functions are a powerful way to traverse / modify an array element
by element. They give ndarray flexibility to perform the operation
as efficiently as possible.</p>

<h1 id='performance' class='section-header'><a href='#performance'>Performance</a></h1>
<p>These operations are efficient in ndarray. Our Rust code is autovectorized
by the compiler.</p>

<pre class='rust rust-example-rendered'>
<span class='comment'>/* Unary op */</span>  <span class='ident'>array1</span> <span class='op'>+=</span> <span class='number'>1.</span>;
<span class='comment'>/* Unary op */</span>  <span class='ident'>array1</span>.<span class='ident'>mapv_inplace</span>(<span class='ident'>f32</span>::<span class='ident'>abs</span>);
<span class='comment'>/* Binary op */</span> <span class='ident'>array1</span> <span class='op'>+=</span> <span class='kw-2'>&amp;</span><span class='ident'>array2</span>;
<span class='comment'>/* Reduction */</span> <span class='ident'>array1</span>.<span class='ident'>scalar_sum</span>();</pre>

<p>(Overloading <code>+=</code> is a Rust 1.8 feature<br> — stable soon! 
)</p>

<p>Matrix multiplication and linear algebra is another story, uses integration
with BLAS.</p>

<h1 id='performance-1' class='section-header'><a href='#performance-1'>Performance</a></h1>
<p>These operations are efficient in ndarray. Our Rust code is autovectorized
by the compiler.</p>

<pre class='rust rust-example-rendered'>
<span class='comment'>/* Unary op */</span>  <span class='ident'>array1</span> <span class='op'>+=</span> <span class='number'>1.</span>;
<span class='comment'>/* Unary op */</span>  <span class='ident'>array1</span>.<span class='ident'>mapv_inplace</span>(<span class='ident'>f32</span>::<span class='ident'>abs</span>);
<span class='comment'>/* Binary op */</span> <span class='ident'>array1</span> <span class='op'>+=</span> <span class='kw-2'>&amp;</span><span class='ident'>array2</span>;
<span class='comment'>/* Reduction */</span> <span class='ident'>array1</span>.<span class='ident'>scalar_sum</span>();</pre>

<p>(Overloading <code>+=</code> is a Rust 1.8 feature<br> — stable in 
 <em id="stableclock"></em>)</p>

<p>Matrix multiplication and linear algebra is another story, uses integration
with BLAS.</p>

<h1 id='performance-secret-1' class='section-header'><a href='#performance-secret-1'>Performance Secret 1</a></h1>
<h1 id='performance-secret-1-1' class='section-header'><a href='#performance-secret-1-1'>Performance Secret 1</a></h1>
<ul>
<li><code>&amp;[T]</code>. A contiguous slice of data.</li>
</ul>

<h1 id='performance-secret-1-2' class='section-header'><a href='#performance-secret-1-2'>Performance Secret 1</a></h1>
<ul>
<li><code>&amp;[T]</code>. A contiguous slice of data.</li>
</ul>

<p>Ndarray operations are efficient when they access the underlying data as a slice.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>unary_operation</span>(<span class='ident'>data</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='ident'>f32</span>]) {
    <span class='kw'>for</span> <span class='ident'>element</span> <span class='kw'>in</span> <span class='ident'>data</span> {
        <span class='op'>*</span><span class='ident'>element</span> <span class='op'>+=</span> <span class='number'>1.</span>;
    }
}</pre>

<h1 id='performance-secret-2' class='section-header'><a href='#performance-secret-2'>Performance Secret 2</a></h1>
<p>Iterate two slices in lock step.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>binary_operation</span>(<span class='ident'>a</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='ident'>f32</span>], <span class='ident'>b</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f32</span>]) {
    <span class='kw'>let</span> <span class='ident'>len</span> <span class='op'>=</span> <span class='ident'>std</span>::<span class='ident'>cmp</span>::<span class='ident'>min</span>(<span class='ident'>a</span>.<span class='ident'>len</span>(), <span class='ident'>b</span>.<span class='ident'>len</span>());
    <span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>a</span>[..<span class='ident'>len</span>];
    <span class='kw'>let</span> <span class='ident'>b</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>b</span>[..<span class='ident'>len</span>];

    <span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> <span class='number'>0</span>..<span class='ident'>len</span> {
        <span class='ident'>a</span>[<span class='ident'>i</span>] <span class='op'>+=</span> <span class='ident'>b</span>[<span class='ident'>i</span>];
    }
}</pre>

<h1 id='performance-secret-3' class='section-header'><a href='#performance-secret-3'>Performance Secret 3</a></h1>
<p>Autovectorize a floating point sum.</p>

<p><em>Ideally...</em></p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>sum</span>(<span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f32</span>]) <span class='op'>-&gt;</span> <span class='ident'>f32</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>sum</span> <span class='op'>=</span> <span class='number'>0.</span>;
    <span class='kw'>for</span> <span class='kw-2'>&amp;</span><span class='ident'>element</span> <span class='kw'>in</span> <span class='ident'>data</span> {
        <span class='ident'>sum</span> <span class='op'>+=</span> <span class='ident'>element</span>;
    }
    <span class='ident'>sum</span>
}</pre>

<h1 id='performance-secret-3-1' class='section-header'><a href='#performance-secret-3-1'>Performance Secret 3</a></h1>
<p>Autovectorize a floating point sum.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>sum</span>(<span class='kw-2'>mut</span> <span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f32</span>]) <span class='op'>-&gt;</span> <span class='ident'>f32</span> {
    <span class='kw'>let</span> (<span class='kw-2'>mut</span> <span class='ident'>s0</span>, <span class='kw-2'>mut</span> <span class='ident'>s1</span>, <span class='kw-2'>mut</span> <span class='ident'>s2</span>, <span class='kw-2'>mut</span> <span class='ident'>s3</span>,
         <span class='kw-2'>mut</span> <span class='ident'>s4</span>, <span class='kw-2'>mut</span> <span class='ident'>s5</span>, <span class='kw-2'>mut</span> <span class='ident'>s6</span>, <span class='kw-2'>mut</span> <span class='ident'>s7</span>) <span class='op'>=</span>
        (<span class='number'>0.</span>, <span class='number'>0.</span>, <span class='number'>0.</span>, <span class='number'>0.</span>, <span class='number'>0.</span>, <span class='number'>0.</span>, <span class='number'>0.</span>, <span class='number'>0.</span>);

    <span class='kw'>while</span> <span class='ident'>data</span>.<span class='ident'>len</span>() <span class='op'>&gt;=</span> <span class='number'>8</span> {
        <span class='ident'>s0</span> <span class='op'>+=</span> <span class='ident'>data</span>[<span class='number'>0</span>]; <span class='ident'>s1</span> <span class='op'>+=</span> <span class='ident'>data</span>[<span class='number'>1</span>];
        <span class='ident'>s2</span> <span class='op'>+=</span> <span class='ident'>data</span>[<span class='number'>2</span>]; <span class='ident'>s3</span> <span class='op'>+=</span> <span class='ident'>data</span>[<span class='number'>3</span>];
        <span class='ident'>s4</span> <span class='op'>+=</span> <span class='ident'>data</span>[<span class='number'>4</span>]; <span class='ident'>s5</span> <span class='op'>+=</span> <span class='ident'>data</span>[<span class='number'>5</span>];
        <span class='ident'>s6</span> <span class='op'>+=</span> <span class='ident'>data</span>[<span class='number'>6</span>]; <span class='ident'>s7</span> <span class='op'>+=</span> <span class='ident'>data</span>[<span class='number'>7</span>];
        <span class='ident'>data</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>data</span>[<span class='number'>8</span>..];
    }
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>sum</span> <span class='op'>=</span> <span class='number'>0.</span>;
    <span class='ident'>sum</span> <span class='op'>+=</span> <span class='ident'>s0</span> <span class='op'>+</span> <span class='ident'>s4</span>; <span class='ident'>sum</span> <span class='op'>+=</span> <span class='ident'>s1</span> <span class='op'>+</span> <span class='ident'>s5</span>;
    <span class='ident'>sum</span> <span class='op'>+=</span> <span class='ident'>s2</span> <span class='op'>+</span> <span class='ident'>s6</span>; <span class='ident'>sum</span> <span class='op'>+=</span> <span class='ident'>s3</span> <span class='op'>+</span> <span class='ident'>s7</span>;
    <span class='kw'>for</span> <span class='ident'>i</span> <span class='kw'>in</span> <span class='number'>0</span>..<span class='ident'>data</span>.<span class='ident'>len</span>() {
        <span class='ident'>sum</span> <span class='op'>+=</span> <span class='ident'>data</span>[<span class='ident'>i</span>];
    }
    <span class='ident'>sum</span>
}</pre>

<h1 id='performance-secrets' class='section-header'><a href='#performance-secrets'>Performance Secrets</a></h1>
<ul>
<li><code>&amp;[T]</code>. A contiguous slice of data.</li>
</ul>

<p>Ndarray operations are efficient when they access the underlying data as a slice
(they do when the memory layout allows).</p>

<ul>
<li>If the array is contiguous, use it as a slice.</li>
<li>If the array has contiguous rows or columns, iterate over their slices.</li>
<li>Unary transformations don’t care which order elements are accessed.</li>
<li>Efficient binary operations require that the array layouts line
up to some extent.</li>
<li>Regular loops optimize with autovectorization if we’re careful.</li>
</ul>

<h1 id='design-choices' class='section-header'><a href='#design-choices'>Design Choices</a></h1>
<ul>
<li>A type parameter for dimensionality

<ul>
<li>Statically distinguishes a 1D view from a 2D view and so on</li>
<li>The low dimensional views are lightweight</li>
<li>and easy to see through for the optimizing compiler</li>
<li>...but we have no operations that dynamically change the number of axes of an array.</li>
</ul></li>
<li>A signed stride per axis

<ul>
<li>Can represent different memory layouts</li>
<li>...but some operations must have multiple cases depending on layout</li>
</ul></li>
</ul>

<h1 id='end' class='section-header'><a href='#end'>End</a></h1>
<ul>
<li>ndarray is focused on the data structure.</li>
<li>We want to do the basics right and make it easy to extend.</li>
<li>For more information, see our <a href="https://github.com/bluss/rust-ndarray">github</a> or the <a href="https://bluss.github.io/rust-ndarray/">ndarray documentation</a>.</li>
</ul>

<!-- vim: sts=4 sw=4 et
-->

    <script type="text/javascript">
        window.playgroundUrl = "";
    </script>
    
</body>
</html>